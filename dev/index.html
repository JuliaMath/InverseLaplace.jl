<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · InverseLaplace.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>InverseLaplace.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Inverse-Laplace-transform-algorithms"><span>Inverse Laplace transform algorithms</span></a></li><li><a class="tocitem" href="#Setting-parameters"><span>Setting parameters</span></a></li><li><a class="tocitem" href="#Analzying-accuracy"><span>Analzying accuracy</span></a></li><li><a class="tocitem" href="#Lower-level-interface"><span>Lower-level interface</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaMath/InverseLaplace.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="InverseLaplace"><a class="docs-heading-anchor" href="#InverseLaplace">InverseLaplace</a><a id="InverseLaplace-1"></a><a class="docs-heading-anchor-permalink" href="#InverseLaplace" title="Permalink"></a></h1><p><em>Numerical inverse Laplace transform</em></p><p>The source repository is <a href="https://github.com/JuliaMath/InverseLaplace.jl">https://github.com/JuliaMath/InverseLaplace.jl</a>.</p><p>This package provides three algorithms for numerically inverting Laplace transforms.</p><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#InverseLaplace">InverseLaplace</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li><li><a href="#Inverse-Laplace-transform-algorithms">Inverse Laplace transform algorithms</a></li><li><a href="#Setting-parameters">Setting parameters</a></li><li><a href="#Analzying-accuracy">Analzying accuracy</a></li><li><a href="#Lower-level-interface">Lower-level interface</a></li><li><a href="#References">References</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#InverseLaplace.GWR"><code>InverseLaplace.GWR</code></a></li><li><a href="#InverseLaplace.ILtPair"><code>InverseLaplace.ILtPair</code></a></li><li><a href="#InverseLaplace.Talbot"><code>InverseLaplace.Talbot</code></a></li><li><a href="#InverseLaplace.TransformPair"><code>InverseLaplace.TransformPair</code></a></li><li><a href="#InverseLaplace.Weeks"><code>InverseLaplace.Weeks</code></a></li><li><a href="#InverseLaplace.WeeksErr"><code>InverseLaplace.WeeksErr</code></a></li><li><a href="#InverseLaplace.ILT"><code>InverseLaplace.ILT</code></a></li><li><a href="#InverseLaplace.abserr"><code>InverseLaplace.abserr</code></a></li><li><a href="#InverseLaplace.gaverstehfest"><code>InverseLaplace.gaverstehfest</code></a></li><li><a href="#InverseLaplace.gwr"><code>InverseLaplace.gwr</code></a></li><li><a href="#InverseLaplace.ilt"><code>InverseLaplace.ilt</code></a></li><li><a href="#InverseLaplace.iltpair_power"><code>InverseLaplace.iltpair_power</code></a></li><li><a href="#InverseLaplace.setNterms"><code>InverseLaplace.setNterms</code></a></li><li><a href="#InverseLaplace.setparameters"><code>InverseLaplace.setparameters</code></a></li><li><a href="#InverseLaplace.talbot"><code>InverseLaplace.talbot</code></a></li><li><a href="#InverseLaplace.talbotarr"><code>InverseLaplace.talbotarr</code></a></li></ul><h2 id="Inverse-Laplace-transform-algorithms"><a class="docs-heading-anchor" href="#Inverse-Laplace-transform-algorithms">Inverse Laplace transform algorithms</a><a id="Inverse-Laplace-transform-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Inverse-Laplace-transform-algorithms" title="Permalink"></a></h2><p>Constructing these Julia types, corresponding to different numerical algorithms, returns a callable object that evaluates the inverse Laplace transform at specified points.</p><article class="docstring"><header><a class="docstring-binding" id="InverseLaplace.Talbot" href="#InverseLaplace.Talbot"><code>InverseLaplace.Talbot</code></a> — <span class="docstring-category">Type</span></header><section><div><p>ft::Talbot = Talbot(func::Function, Nterms::Integer=32)</p><p>Return <code>ft</code>, which estimates the inverse Laplace transform of <code>func</code> with the fixed Talbot algorithm. <code>ft(t)</code> evaluates the transform at <code>t</code>.  You may want to tune <code>Nterms</code> together with <code>setprecision(BigFloat, x)</code>.</p><p><strong>Example</strong></p><p>Compute the inverse transform of the transform of <code>cos</code> at argument <code>pi/2</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; ft = Talbot(s -&gt; s / (s^2 + 1), 80);

julia&gt; ft(pi / 2)
-3.5366510684573195e-5</code></pre><p>Note that given <code>Float64</code> input, the precision of the returned value may not be satisfactory.</p><pre><code class="language-julia-repl hljs">julia&gt; Float64(ft(big(pi) / 2))
2.114425886215604e-49</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function uses the fixed Talbot method. It evaluates the Laplace transform function for complex arguments. The GWR method is, in general, less accurate and less stable, but does not evaluate the Laplace transform function for complex arguments.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/InverseLaplace.jl/blob/89a7def4dd9240a45771266e971988e9c07caf67/src/InverseLaplace.jl#LL18-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InverseLaplace.ILT" href="#InverseLaplace.ILT"><code>InverseLaplace.ILT</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ILT(function, Nterms=32)</code></pre><p>This is an alias for the default <code>Talbot()</code> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/InverseLaplace.jl/blob/89a7def4dd9240a45771266e971988e9c07caf67/src/InverseLaplace.jl#LL78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InverseLaplace.GWR" href="#InverseLaplace.GWR"><code>InverseLaplace.GWR</code></a> — <span class="docstring-category">Type</span></header><section><div><p>ft::GWR = GWR(func::Function, Nterms::Integer=16)</p><p>Return <code>ft</code>, which estimates the inverse Laplace transform of <code>func</code> with the GWR algorithm. <code>ft(t)</code> evaluates the transform at <code>t</code>.</p><p><strong>Example</strong></p><p>Compute the inverse transform of the transform of <code>cos</code> at argument <code>pi / 2</code>.</p><pre><code class="nohighlight hljs">julia&gt; ft = GWR(s -&gt; s / (s^2 + 1), 16);

julia&gt; ft(pi / 2)
-0.001</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/InverseLaplace.jl/blob/89a7def4dd9240a45771266e971988e9c07caf67/src/InverseLaplace.jl#LL54-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InverseLaplace.Weeks" href="#InverseLaplace.Weeks"><code>InverseLaplace.Weeks</code></a> — <span class="docstring-category">Type</span></header><section><div><p>w::Weeks{datatype} = Weeks(func::Function, Nterms::Integer=64, sigma=1.0, b=1.0; datatype=Float64)</p><p>Return <code>w</code>, which estimates the inverse Laplace transform of <code>func</code> with the Weeks algorithm. <code>w(t)</code> evaluates the transform at <code>t</code>. The accuracy depends on the choice of <code>sigma</code> and <code>b</code>, with the optimal choices depending on <code>t</code>. <code>datatype</code> should agree with the <code>DataType</code> returned by <code>func</code>. For convenience, <code>datatype=Complex</code> is equivalent to <code>datatype=Complex{Float64}</code></p><p>The call to <code>Weeks</code> that creates <code>w</code> is expensive relative to evaluation via <code>w(t)</code>.</p><p><strong>Example</strong></p><p>Compute the inverse transform of the transform of <code>cos</code> at argument <code>pi/2</code>.</p><pre><code class="nohighlight hljs">julia&gt; ft = Weeks(s -&gt; s/(s^2+1), 80);

julia&gt; ft(pi/2)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/InverseLaplace.jl/blob/89a7def4dd9240a45771266e971988e9c07caf67/src/weeks.jl#LL31-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InverseLaplace.WeeksErr" href="#InverseLaplace.WeeksErr"><code>InverseLaplace.WeeksErr</code></a> — <span class="docstring-category">Type</span></header><section><div><p>w::WeeksErr{datatype} = WeeksErr(func::Function, Nterms::Integer=64, sigma=1.0, b=1.0; datatype=Float64)</p><p>Return <code>w</code>, which estimates the inverse Laplace transform of <code>func</code> via the Weeks algorithm. <code>w(t)</code> returns a tuple containing the inverse transform at <code>t</code> and an error estimate. The accuracy of the inversion depends on the choice of <code>sigma</code> and <code>b</code>. See the documentation for <code>Weeks</code> for a description of the parameter <code>datatype</code>.</p><p><strong>Example</strong></p><p>Compute the inverse transform of the transform of <code>cos</code>, and an error estimate, at argument <code>pi/2</code> using <code>80</code> terms.</p><pre><code class="nohighlight hljs">julia&gt; ft = WeeksErr(s -&gt; s/(s^2+1), 80);

julia&gt; ft(pi/2)
(0.0,3.0872097665938698e-15)</code></pre><p>This estimate is more accurate than <code>cos(pi/2)</code>.</p><pre><code class="nohighlight hljs">julia&gt; ft(pi/2)[1] - cos(pi/2)
-6.123233995736766e-17

julia&gt; ft(pi/2)[1] - 0.0         # exact value
0.0

julia&gt; ft(pi/2)[1] - cospi(1/2)  # cospi is more accurate
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/InverseLaplace.jl/blob/89a7def4dd9240a45771266e971988e9c07caf67/src/weeks.jl#LL165-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InverseLaplace.gaverstehfest" href="#InverseLaplace.gaverstehfest"><code>InverseLaplace.gaverstehfest</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gaverstehfest(func::Function, t::AbstractFloat, v = stehfest_coeffs(N))</code></pre><p>Evaluate the inverse Laplace transform of <code>func</code> at the point <code>t</code> using the Gaver-Stehfest algorithm. <code>v</code> are the stehfest coefficients computed with <code>stehfest_coeffs</code> that only depend on number of terms.  N (which must be even) defaults to 36 should depend on the precision used and desired accuracy. The precision of the stehfest coefficients is used in the computation. </p><p>In double precision (Float64), N should be &lt;= 18 to provide best accuracy. Usually only moderate accuracy can be achieved in double precision ~rtol ≈ 1e-4. For higher accuracy, BigFloats should be used with N = 36.</p><p>Increasing precision should be accompanied by an increase in the number of coefficients used. Increasing precision without increasing number of coefficients will not yield better accuracy. The inverse is generally true as well.</p><p>This method is not robust to oscillating F(t) and must be smooth.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; F(s) = 1 / (s + 1) # where analytical inverse is f(t) = exp(-t)

julia&gt; InverseLaplace.gaverstehfest(F, 2.0) # computes with default 36 coefficients
0.1353352832366128315426471959891170863784520272858265151734040491181311503059561

julia&gt; InverseLaplace.gaverstehfest(F, 2.0, v = stehfest_coeffs(20)) # computes with custom number
0.1353353114073885136885007645878189977740624364169818512599342310325432753817199

# to calculate in double precision convert stehfest coefficients to Float64
julia&gt; InverseLaplace.gaverstehfest(F, 2.0, v = convert(Vector{Float64}, stehfest_coeffs(18)))
0.13533650985980258</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/InverseLaplace.jl/blob/89a7def4dd9240a45771266e971988e9c07caf67/src/gaverstehfest.jl#LL39-L70">source</a></section><section><div><pre><code class="nohighlight hljs">gaverstehfest(func::Function, t::AbstractArray, v = stehfest_coeffs(N))</code></pre><p>Evaluate the inverse Laplace transform of <code>func</code> over an array of <code>t</code> using the Gaver-Stehfest algorithm. Computes coefficients once and calculates f(t) across available threads.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; gaverstehfest(s -&gt; 1/(s + 1), 2.0:4.0)
0.1353355048178631463198819259249043857320738467297190227379428405365703748720082
0.04978728177016550841951683309410878070827215175940039571536203126773133604403101
0.01831383641619355549133471411401755204406266755309342902744499924574072011058623</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/InverseLaplace.jl/blob/89a7def4dd9240a45771266e971988e9c07caf67/src/gaverstehfest.jl#LL81-L94">source</a></section></article><h2 id="Setting-parameters"><a class="docs-heading-anchor" href="#Setting-parameters">Setting parameters</a><a id="Setting-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-parameters" title="Permalink"></a></h2><p>The inverse Laplace tranform routines should not be treated as black boxes. They are prone to instability and can give inaccurate or wrong results. There are some parameters you can set to try to minimize these problems.</p><article class="docstring"><header><a class="docstring-binding" id="InverseLaplace.setNterms" href="#InverseLaplace.setNterms"><code>InverseLaplace.setNterms</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setNterms(ailt::AbstractILt, Nterms::Integer)</code></pre><p>set the number of terms used in the inverse Laplace tranform <code>ailt</code>. If <code>ailt</code> stores internal data, it will be recomputed, so that subsequent calls <code>ailt(t)</code> reflect the new value of <code>Nterms</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/InverseLaplace.jl/blob/89a7def4dd9240a45771266e971988e9c07caf67/src/InverseLaplace.jl#LL135-L141">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>InverseLaplace.optimize</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>InverseLaplace.opteval</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="InverseLaplace.setparameters" href="#InverseLaplace.setparameters"><code>InverseLaplace.setparameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setparameters(w::AbstractWeeks, sigma, b, Nterms)</code></pre><p>Set the parameters for the inverse Laplace transform object <code>w</code> and recompute the internal data. Subsequent calls <code>w(t)</code> will use these parameters. If <code>Nterms</code> or both <code>Nterms</code> and <code>b</code> are omitted, then their current values are retained.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/InverseLaplace.jl/blob/89a7def4dd9240a45771266e971988e9c07caf67/src/weeks.jl#LL111-L117">source</a></section></article><h2 id="Analzying-accuracy"><a class="docs-heading-anchor" href="#Analzying-accuracy">Analzying accuracy</a><a id="Analzying-accuracy-1"></a><a class="docs-heading-anchor-permalink" href="#Analzying-accuracy" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="InverseLaplace.ILtPair" href="#InverseLaplace.ILtPair"><code>InverseLaplace.ILtPair</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ILtPair(ilt::AbstractILt, ft::Function)</code></pre><p>return an object of type <code>ILtPair</code> that associates <code>ilt</code> the inverse Laplace transform of a function with it &quot;exact&quot; numerical inverse <code>ft</code>. Calling <code>abserr(p, t)</code> returns the absolute error between the inverse transform and the exact value.</p><p><strong>Example</strong></p><p>This example compares the inversion using the Weeks algorithm of the Laplace transform of <code>cos(t)</code> to its exact value at <code>t=1.0</code>.</p><pre><code class="nohighlight hljs">julia&gt; p = ILtPair(Weeks(s -&gt; s/(1+s^2)), cos);
julia&gt; abserr(p, 1.0)

0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/InverseLaplace.jl/blob/89a7def4dd9240a45771266e971988e9c07caf67/src/pairtest.jl#LL14-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InverseLaplace.abserr" href="#InverseLaplace.abserr"><code>InverseLaplace.abserr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">abserr(p::ILtPair, t)</code></pre><p>Compute the absolute error between the estimated inverse Laplace transform and &quot;exact&quot; numerical solution contained in <code>p</code> at the point <code>t</code>. See <code>ILtPair</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/InverseLaplace.jl/blob/89a7def4dd9240a45771266e971988e9c07caf67/src/pairtest.jl#LL57-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InverseLaplace.iltpair_power" href="#InverseLaplace.iltpair_power"><code>InverseLaplace.iltpair_power</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iltpair_power(n)</code></pre><p>Return a <code>TransformPair</code> for the power function <code>x^n</code>. This can be used to construct an <code>ILTPair</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; p  = Talbot(iltpair_power(3));

julia&gt; Float64(abserr(p, 1)) # test Talbot method for Laplace transform of x^3, evaluated at 1
2.0820366247539812e-26</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/InverseLaplace.jl/blob/89a7def4dd9240a45771266e971988e9c07caf67/src/pairtest.jl#LL38-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InverseLaplace.TransformPair" href="#InverseLaplace.TransformPair"><code>InverseLaplace.TransformPair</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TransformPair{T,V}</code></pre><p>A pair of functions for analyzing an inverse Laplace transform method. Field <code>ft</code> is the real-space function. Field <code>fs</code> is the Laplace-space function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/InverseLaplace.jl/blob/89a7def4dd9240a45771266e971988e9c07caf67/src/pairtest.jl#LL3-L8">source</a></section></article><h2 id="Lower-level-interface"><a class="docs-heading-anchor" href="#Lower-level-interface">Lower-level interface</a><a id="Lower-level-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Lower-level-interface" title="Permalink"></a></h2><p>Some of the lower-level routines can be called directly, without constructing types defined in <code>InverseLaplace</code>.</p><article class="docstring"><header><a class="docstring-binding" id="InverseLaplace.ilt" href="#InverseLaplace.ilt"><code>InverseLaplace.ilt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ilt(func::Function, t::AbstractFloat, M::Integer=32)</code></pre><p><code>ilt</code> is an alias for the default inverse Laplace transform method <code>talbot</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/InverseLaplace.jl/blob/89a7def4dd9240a45771266e971988e9c07caf67/src/InverseLaplace.jl#LL127-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InverseLaplace.talbot" href="#InverseLaplace.talbot"><code>InverseLaplace.talbot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">talbot(func::Function, t::AbstractFloat, M::Integer=talbot_default_num_terms)</code></pre><p>Evaluate the inverse Laplace transform of <code>func</code> at the point <code>t</code>. Use <code>M</code> terms in the algorithm. For <code>typeof(t)</code> is <code>Float64</code>, the default for <code>M</code> is <code>32</code>. For <code>BigFloat</code> the default is <code>64</code>.</p><p>If <code>BigFloat</code> precision is larger than default, try increasing <code>M</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; InverseLaplace.talbot(s -&gt; 1 / s^3, 3)
4.50000000000153</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function uses the fixed Talbot method. It evaluates <code>func</code> for complex arguments.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/InverseLaplace.jl/blob/89a7def4dd9240a45771266e971988e9c07caf67/src/fixed_talbot.jl#LL7-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InverseLaplace.gwr" href="#InverseLaplace.gwr"><code>InverseLaplace.gwr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gwr(func::Function, t::AbstractFloat, M::Integer=gwr_default_num_terms)</code></pre><p>Evaluate the inverse Laplace transform of <code>func</code> at the point <code>t</code>. Use <code>M</code> terms in the algorithm. For <code>typeof(t)</code> is <code>Float64</code>, the default for <code>M</code> is <code>16</code>. For <code>BigFloat</code> the default is <code>64</code>.</p><p>If <code>BigFloat</code> precision is larger than default, try increasing <code>M</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; InverseLaplace.gwr( s -&gt; 1/s^3, 3.0)
4.499985907607361</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function uses the Gaver-Wynn rho method. It evaluates <code>func</code> only for real arguments.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/InverseLaplace.jl/blob/89a7def4dd9240a45771266e971988e9c07caf67/src/gwr.jl#LL12-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InverseLaplace.talbotarr" href="#InverseLaplace.talbotarr"><code>InverseLaplace.talbotarr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">talbotarr(func, ta::AbstractArray, M)</code></pre><p>Compute the inverse Laplace transform for each element in <code>ta</code>. Each evaluation of <code>func(s)</code> is used for all elements of <code>ta</code>. This may be faster than a broadcast application of <code>talbot</code> (i.e. <code>talbot.(...</code>) , but is in general, less accurate.  <code>talbotarr</code> uses the &quot;fixed&quot; Talbot method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/InverseLaplace.jl/blob/89a7def4dd9240a45771266e971988e9c07caf67/src/fixed_talbot.jl#LL50-L57">source</a></section></article><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>J.A.C Weideman, <em>Algorithms for Parameter Selection in the Weeks Method for Inverting the Laplace Transform, SIAM Journal on Scientific Computing</em>, Vol. 21, pp. 111-128 <strong>(1999)</strong></p><p>Abate, J. and Valkó, P.P., <em>Multi-precision Laplace transform inversion International Journal for Numerical Methods in Engineering</em>, Vol. 60 (Iss. 5-7) pp 979–993 <strong>(2004)</strong></p><p>Valkó, P.P. and Abate, J., <em>Comparison of Sequence Accelerators for the Gaver Method of Numerical Laplace Transform Inversion</em>, Computers and Mathematics with Application,  Vol. 48 (Iss.3-40) pp. 629-636 <strong>(2004)</strong></p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 4 May 2023 20:09">Thursday 4 May 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
