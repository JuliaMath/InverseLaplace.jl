<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>InverseLaplace · InverseLaplace.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>InverseLaplace.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">InverseLaplace</a><ul class="internal"><li><a class="toctext" href="#Contents-1">Contents</a></li><li><a class="toctext" href="#Index-1">Index</a></li><li><a class="toctext" href="#Inverse-Laplace-transform-methods-1">Inverse Laplace transform methods</a></li><li><a class="toctext" href="#Setting-parameters-1">Setting parameters</a></li><li><a class="toctext" href="#Analzying-accuracy-1">Analzying accuracy</a></li><li><a class="toctext" href="#Lower-level-interface-1">Lower-level interface</a></li><li><a class="toctext" href="#References-1">References</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">InverseLaplace</a></li></ul><a class="edit-page" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>InverseLaplace</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="InverseLaplace-1" href="#InverseLaplace-1">InverseLaplace</a></h1><p><em>Numerical inverse Laplace transform.</em></p><p>The source repository is https://github.com/jlapeyre/InverseLaplace.jl .</p><h2><a class="nav-anchor" id="Contents-1" href="#Contents-1">Contents</a></h2><ul><li><a href="index.html#InverseLaplace-1">InverseLaplace</a></li><ul><li><a href="index.html#Contents-1">Contents</a></li><li><a href="index.html#Index-1">Index</a></li><li><a href="index.html#Inverse-Laplace-transform-methods-1">Inverse Laplace transform methods</a></li><li><a href="index.html#Setting-parameters-1">Setting parameters</a></li><li><a href="index.html#Analzying-accuracy-1">Analzying accuracy</a></li><li><a href="index.html#Lower-level-interface-1">Lower-level interface</a></li><li><a href="index.html#References-1">References</a></li></ul></ul><h2><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h2><ul><li><a href="index.html#InverseLaplace.GWR"><code>InverseLaplace.GWR</code></a></li><li><a href="index.html#InverseLaplace.ILtPair"><code>InverseLaplace.ILtPair</code></a></li><li><a href="index.html#InverseLaplace.Talbot"><code>InverseLaplace.Talbot</code></a></li><li><a href="index.html#InverseLaplace.Weeks"><code>InverseLaplace.Weeks</code></a></li><li><a href="index.html#InverseLaplace.WeeksErr"><code>InverseLaplace.WeeksErr</code></a></li><li><a href="index.html#InverseLaplace.ILT"><code>InverseLaplace.ILT</code></a></li><li><a href="index.html#InverseLaplace.abserr"><code>InverseLaplace.abserr</code></a></li><li><a href="index.html#InverseLaplace.gwr"><code>InverseLaplace.gwr</code></a></li><li><a href="index.html#InverseLaplace.ilt"><code>InverseLaplace.ilt</code></a></li><li><a href="index.html#InverseLaplace.opteval"><code>InverseLaplace.opteval</code></a></li><li><a href="index.html#InverseLaplace.optimize"><code>InverseLaplace.optimize</code></a></li><li><a href="index.html#InverseLaplace.setNterms"><code>InverseLaplace.setNterms</code></a></li><li><a href="index.html#InverseLaplace.setparameters"><code>InverseLaplace.setparameters</code></a></li><li><a href="index.html#InverseLaplace.talbot"><code>InverseLaplace.talbot</code></a></li><li><a href="index.html#InverseLaplace.talbotarr"><code>InverseLaplace.talbotarr</code></a></li></ul><h2><a class="nav-anchor" id="Inverse-Laplace-transform-methods-1" href="#Inverse-Laplace-transform-methods-1">Inverse Laplace transform methods</a></h2><p>Constructing these Julia types, corresponding to different numerical methods, returns a callable object that evaluates the inverse transform at specified points.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.ILT" href="#InverseLaplace.ILT"><code>InverseLaplace.ILT</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ILT(function, Nterms=32)</code></pre><p>This is an alias for the default <code>Talbot()</code> method.</p></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/ac8999dd084c549bd82b55868ab000b44087987d/src/InverseLaplace.jl#L76-L80">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.Talbot" href="#InverseLaplace.Talbot"><code>InverseLaplace.Talbot</code></a> — <span class="docstring-category">Type</span>.</div><div><p>ft::Talbot = Talbot(func::Function, Nterms::Integer=32)</p><p>return <code>ft</code>, which estimates the inverse Laplace transform of <code>func</code> with the fixed Talbot algorithm. <code>ft(t)</code> evaluates the transform at <code>t</code>.</p><p><strong>Example</strong></p><p>Compute the inverse transform of the transform of <code>cos</code> at argument <code>pi/2</code>.</p><pre><code class="language-none">julia&gt; ft = Talbot(s -&gt; s/(s^2+1), 80);

julia&gt; ft(pi/2)
0.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/ac8999dd084c549bd82b55868ab000b44087987d/src/InverseLaplace.jl#L30-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.GWR" href="#InverseLaplace.GWR"><code>InverseLaplace.GWR</code></a> — <span class="docstring-category">Type</span>.</div><div><p>ft::GWR = GWR(func::Function, Nterms::Integer=16)</p><p>return <code>ft</code>, which estimates the inverse Laplace transform of <code>func</code> with the GWR algorithm. <code>ft(t)</code> evaluates the transform at <code>t</code>.</p><p><strong>Example</strong></p><p>Compute the inverse transform of the transform of <code>cos</code> at argument <code>pi/2</code>.</p><pre><code class="language-none">julia&gt; ft = GWR(s -&gt; s/(s^2+1), 16);

julia&gt; ft(pi/2)
-0.001</code></pre></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/ac8999dd084c549bd82b55868ab000b44087987d/src/InverseLaplace.jl#L53-L68">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.Weeks" href="#InverseLaplace.Weeks"><code>InverseLaplace.Weeks</code></a> — <span class="docstring-category">Type</span>.</div><div><p>w::Weeks = Weeks(func::Function, Nterms::Integer=64, sigma=1.0, b=1.0)</p><p>return <code>w</code>, which estimates the inverse Laplace transform of <code>func</code> with the Weeks algorithm. <code>w(t)</code> evaluates the transform at <code>t</code>. The accuracy depends on the choice of <code>sigma</code> and <code>b</code>, with the optimal choices depending on <code>t</code>.</p><p>The call to <code>Weeks</code> that creates <code>w</code> is expensive relative to evaluation via <code>w(t)</code>.</p><p><strong>Example</strong></p><p>Compute the inverse transform of the transform of <code>cos</code> at argument <code>pi/2</code>.</p><pre><code class="language-none">julia&gt; ft = Weeks(s -&gt; s/(s^2+1), 80);

julia&gt; ft(pi/2)
0.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/ac8999dd084c549bd82b55868ab000b44087987d/src/weeks.jl#L29-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.WeeksErr" href="#InverseLaplace.WeeksErr"><code>InverseLaplace.WeeksErr</code></a> — <span class="docstring-category">Type</span>.</div><div><p>w::WeeksErr = WeeksErr(func::Function, Nterms::Integer=64, sigma=1.0, b=1.0)</p><p>return <code>w</code>, which estimates the inverse Laplace transform of <code>func</code> via the Weeks algorithm. <code>w(t)</code> returns a tuple containing the inverse transform at <code>t</code> and an error estimate. The accuracy of the inversion depends on the choice of <code>sigma</code> and <code>b</code>.</p><p><strong>Example</strong></p><p>Compute the inverse transform of the transform of <code>cos</code>, and an error estimate, at argument <code>pi/2</code> using <code>80</code> terms.</p><pre><code class="language-none">julia&gt; ft = Weeks(s -&gt; s/(s^2+1), 80);

julia&gt; ft(pi/2)
(0.0,3.0872097665938698e-15)</code></pre><p>This estimate is more accurate than <code>cos(pi/2)</code>.</p><pre><code class="language-none">julia&gt; ft(pi/2)[1] - cos(pi/2)
-6.123233995736766e-17

julia&gt; ft(pi/2)[1] - 0.0         # exact value
0.0

julia&gt; ft(pi/2)[1] - cospi(1/2)  # cospi is more accurate
0.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/ac8999dd084c549bd82b55868ab000b44087987d/src/weeks.jl#L158-L185">source</a></section><h2><a class="nav-anchor" id="Setting-parameters-1" href="#Setting-parameters-1">Setting parameters</a></h2><p>The inverse Laplace tranform routines should not be treated as black boxes. They are prone to instability and can give inaccurate or wrong results. There are some parameters you can set to try to minimize these problems.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.setNterms" href="#InverseLaplace.setNterms"><code>InverseLaplace.setNterms</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">setNterms(ailt::AbstractILt, Nterms::Integer)</code></pre><p>set the number of terms used in the inverse Laplace tranform <code>ailt</code>. If <code>ailt</code> stores internal data, it will be recomputed, so that subsequent calls <code>ailt(t)</code> reflect the new value of <code>Nterms</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/ac8999dd084c549bd82b55868ab000b44087987d/src/InverseLaplace.jl#L135-L141">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.optimize" href="#InverseLaplace.optimize"><code>InverseLaplace.optimize</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">optimize(w::AbstractWeeks, t, Nterms)</code></pre><p>optimize the parameters of the inverse Laplace transform <code>w</code> at the argument <code>t</code>. If <code>Nterms</code> is ommitted, the current value of <code>w.Nterms</code> is retained.</p><p>The accuracy of the Weeks algorithm depends strongly on <code>t</code>. For some ranges of <code>t</code>, the accuracy is relatively insensitive to the parameters. For other values of <code>t</code>, even using optimized parameters results in estimates of the inverse transform that are extremely inaccurate.</p><p><code>optimize</code> is expensive in CPU time and allocation, it performs nested single-parameter optimization over two parameterss.</p></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/ac8999dd084c549bd82b55868ab000b44087987d/src/weeks.jl#L66-L80">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.opteval" href="#InverseLaplace.opteval"><code>InverseLaplace.opteval</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">opteval{T&lt;:AbstractWeeks}(w::T, t, Nterms)</code></pre><p>estimate an inverse Laplace transform at argument <code>t</code> using <code>w</code> after optimizing the parameters for <code>t</code>. If <code>Nterms</code> is omitted, then the current value of <code>w.Nterms</code> is used.</p><p>Use <code>Weeks</code> or <code>WeeksErr</code> to create <code>w</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/ac8999dd084c549bd82b55868ab000b44087987d/src/weeks.jl#L86-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.setparameters" href="#InverseLaplace.setparameters"><code>InverseLaplace.setparameters</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">setparameters{T&lt;:AbstractWeeks}(w::T, sigma, b, Nterms)</code></pre><p>Set the parameters for the inverse Laplace transform object <code>w</code> and recompute the internal data. Subsequent calls <code>w(t)</code> will use these parameters. If <code>Nterms</code> or both <code>Nterms</code> and <code>b</code> are omitted, then their current values are retained.</p></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/ac8999dd084c549bd82b55868ab000b44087987d/src/weeks.jl#L102-L108">source</a></section><h2><a class="nav-anchor" id="Analzying-accuracy-1" href="#Analzying-accuracy-1">Analzying accuracy</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.ILtPair" href="#InverseLaplace.ILtPair"><code>InverseLaplace.ILtPair</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">p = ILtPair(ilt::AbstractILt, ft::Function)</code></pre><p>return an object of type <code>ILtPair</code> that associates <code>ilt</code> the inverse Laplace transform of a function with it &quot;exact&quot; numerical inverse <code>ft</code>. Calling <code>abserr(p,t)</code> returns the absolute error between the inverse transform and the exact value.</p><p><strong>Example</strong></p><p>This example compares the inversion using the Weeks algorithm of the Laplace transform of <code>cos(t)</code> to its exact value at <code>t=1.0</code>.</p><pre><code class="language-none">julia&gt; p = ILtPair( Weeks( s -&gt; s/(1+s^2) ), cos);
julia&gt; abserr(p,1.0)

0.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/ac8999dd084c549bd82b55868ab000b44087987d/src/test.jl#L6-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.abserr" href="#InverseLaplace.abserr"><code>InverseLaplace.abserr</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">abserr(p::ILtPair, t)</code></pre><p>Compute the absolute error between the estimated inverse Laplace transform and &quot;exact&quot; numerical solution contained in <code>p</code> at the point <code>t</code>. See <code>ILtPair</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/ac8999dd084c549bd82b55868ab000b44087987d/src/test.jl#L36-L41">source</a></section><h2><a class="nav-anchor" id="Lower-level-interface-1" href="#Lower-level-interface-1">Lower-level interface</a></h2><p>Some of the lower-level routines can be called directly, without constructing types defined in <code>InverseLaplace</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.ilt" href="#InverseLaplace.ilt"><code>InverseLaplace.ilt</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ilt(func::Function, t::AbstractFloat, M::Integer=32)</code></pre><p><code>ilt</code> is an alias for the default inverse Laplace transform method <code>talbot</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/ac8999dd084c549bd82b55868ab000b44087987d/src/InverseLaplace.jl#L126-L130">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.talbot" href="#InverseLaplace.talbot"><code>InverseLaplace.talbot</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">talbot(func::Function, t::AbstractFloat, M::Integer=32)</code></pre><p>Evaluate the inverse Laplace transform of <code>func</code> at the point <code>t</code>. Use <code>M</code> terms in the algorithm. For <code>typeof(t)</code> is <code>Float64</code>, the default for <code>M</code> is <code>32</code>. For <code>BigFloat</code> the default is <code>64</code>.</p><p>If <code>BigFloat</code> precision is larger than default, try increasing <code>M</code>. <code>talbot is vectorized over</code>t`.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; InverseLaplace.talbot( s -&gt; 1/s^3,  3)
4.50000000000153</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This function uses the fixed Talbot method. It evaluates <code>func</code> for complex arguments.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/ac8999dd084c549bd82b55868ab000b44087987d/src/fixed_talbot.jl#L6-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.gwr" href="#InverseLaplace.gwr"><code>InverseLaplace.gwr</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gwr(func::Function, t::AbstractFloat, M::Integer=16)</code></pre><p>Evaluate the inverse Laplace transform of <code>func</code> at the point <code>t</code>. Use <code>M</code> terms in the algorithm. For <code>typeof(t)</code> is <code>Float64</code>, the default for <code>M</code> is <code>16</code>. For <code>BigFloat</code> the default is <code>64</code>.</p><p>If <code>BigFloat</code> precision is larger than default, try increasing <code>M</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; InverseLaplace.gwr( s -&gt; 1/s^3,  3.0)
4.499985907607361</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This function uses the Gaver-Wynn rho method. It evaluates <code>func</code> only for real arguments.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/ac8999dd084c549bd82b55868ab000b44087987d/src/gwr.jl#L13-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.talbotarr" href="#InverseLaplace.talbotarr"><code>InverseLaplace.talbotarr</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">talbotarr(func, ta::AbstractArray, M)</code></pre><p>inverse Laplace transform vectorized over <code>ta</code>. Each evaluation of <code>func(s)</code> is used for all elements of <code>ta</code>. This may be faster than a vectorized application of <code>talbot</code>, but is in general, less accurate. <code>talbotarr</code> uses the &quot;fixed&quot; Talbot method.</p></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/ac8999dd084c549bd82b55868ab000b44087987d/src/fixed_talbot.jl#L49-L56">source</a></section><h2><a class="nav-anchor" id="References-1" href="#References-1">References</a></h2><p>J.A.C Weideman, <em>Algorithms for Parameter Selection in the Weeks Method for Inverting the Laplace Transform, SIAM Journal on Scientific Computing</em>, Vol. 21, pp. 111-128 <strong>(1999)</strong></p><p>Abate, J. and Valkó, P.P., <em>Multi-precision Laplace transform inversion International Journal for Numerical Methods in Engineering</em>, Vol. 60 (Iss. 5-7) pp 979–993 <strong>(2004)</strong></p><p>Valkó, P.P. and Abate, J., <em>Comparison of Sequence Accelerators for the Gaver Method of Numerical Laplace Transform Inversion</em>, Computers and Mathematics with Application,  Vol. 48 (Iss.3-40) pp. 629-636 <strong>(2004)</strong></p><footer><hr/></footer></article></body></html>
