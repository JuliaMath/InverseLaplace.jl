<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>InverseLaplace · InverseLaplace.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>InverseLaplace.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">InverseLaplace</a><ul class="internal"><li><a class="toctext" href="#Contents-1">Contents</a></li><li><a class="toctext" href="#Index-1">Index</a></li><li><a class="toctext" href="#Inverse-Laplace-transform-algorithms-1">Inverse Laplace transform algorithms</a></li><li><a class="toctext" href="#Setting-parameters-1">Setting parameters</a></li><li><a class="toctext" href="#Analzying-accuracy-1">Analzying accuracy</a></li><li><a class="toctext" href="#Lower-level-interface-1">Lower-level interface</a></li><li><a class="toctext" href="#References-1">References</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">InverseLaplace</a></li></ul><a class="edit-page" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>InverseLaplace</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="InverseLaplace-1" href="#InverseLaplace-1">InverseLaplace</a></h1><p><em>Numerical inverse Laplace transform</em></p><p>The source repository is <a href="https://github.com/jlapeyre/InverseLaplace.jl">https://github.com/jlapeyre/InverseLaplace.jl</a>.</p><p>This package provides three algorithms for numerically inverting Laplace transforms. <code>InverseLaplace</code> v0.1.0 is the last version that supports Julia v0.6. Optimization of the Weeks method is temporarily disabled for Julia v0.7.</p><h2><a class="nav-anchor" id="Contents-1" href="#Contents-1">Contents</a></h2><ul><li><a href="index.html#InverseLaplace-1">InverseLaplace</a></li><ul><li><a href="index.html#Contents-1">Contents</a></li><li><a href="index.html#Index-1">Index</a></li><li><a href="index.html#Inverse-Laplace-transform-algorithms-1">Inverse Laplace transform algorithms</a></li><li><a href="index.html#Setting-parameters-1">Setting parameters</a></li><li><a href="index.html#Analzying-accuracy-1">Analzying accuracy</a></li><li><a href="index.html#Lower-level-interface-1">Lower-level interface</a></li><li><a href="index.html#References-1">References</a></li></ul></ul><h2><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h2><ul><li><a href="index.html#InverseLaplace.GWR"><code>InverseLaplace.GWR</code></a></li><li><a href="index.html#InverseLaplace.ILtPair"><code>InverseLaplace.ILtPair</code></a></li><li><a href="index.html#InverseLaplace.Talbot"><code>InverseLaplace.Talbot</code></a></li><li><a href="index.html#InverseLaplace.TransformPair"><code>InverseLaplace.TransformPair</code></a></li><li><a href="index.html#InverseLaplace.Weeks"><code>InverseLaplace.Weeks</code></a></li><li><a href="index.html#InverseLaplace.WeeksErr"><code>InverseLaplace.WeeksErr</code></a></li><li><a href="index.html#InverseLaplace.ILT"><code>InverseLaplace.ILT</code></a></li><li><a href="index.html#InverseLaplace.abserr"><code>InverseLaplace.abserr</code></a></li><li><a href="index.html#InverseLaplace.gwr"><code>InverseLaplace.gwr</code></a></li><li><a href="index.html#InverseLaplace.ilt"><code>InverseLaplace.ilt</code></a></li><li><a href="index.html#InverseLaplace.iltpair_power"><code>InverseLaplace.iltpair_power</code></a></li><li><a href="index.html#InverseLaplace.opteval"><code>InverseLaplace.opteval</code></a></li><li><a href="index.html#InverseLaplace.optimize"><code>InverseLaplace.optimize</code></a></li><li><a href="index.html#InverseLaplace.setNterms"><code>InverseLaplace.setNterms</code></a></li><li><a href="index.html#InverseLaplace.setparameters"><code>InverseLaplace.setparameters</code></a></li><li><a href="index.html#InverseLaplace.talbot"><code>InverseLaplace.talbot</code></a></li><li><a href="index.html#InverseLaplace.talbotarr"><code>InverseLaplace.talbotarr</code></a></li></ul><h2><a class="nav-anchor" id="Inverse-Laplace-transform-algorithms-1" href="#Inverse-Laplace-transform-algorithms-1">Inverse Laplace transform algorithms</a></h2><p>Constructing these Julia types, corresponding to different numerical algorithms, returns a callable object that evaluates the inverse Laplace transform at specified points.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.Talbot" href="#InverseLaplace.Talbot"><code>InverseLaplace.Talbot</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>ft::Talbot = Talbot(func::Function, Nterms::Integer=32)</p><p>Return <code>ft</code>, which estimates the inverse Laplace transform of <code>func</code> with the fixed Talbot algorithm. <code>ft(t)</code> evaluates the transform at <code>t</code>.  You may want to tune <code>Nterms</code> together with <code>setprecision(BigFloat, x)</code>.</p><p><strong>Example</strong></p><p>Compute the inverse transform of the transform of <code>cos</code> at argument <code>pi/2</code>.</p><pre><code class="language-julia-repl">julia&gt; ft = Talbot(s -&gt; s / (s^2 + 1), 80);

julia&gt; ft(pi / 2)
-3.5366510684573195e-5</code></pre><p>Note that given <code>Float64</code> input, the precision of the returned value may not be satisfactory.</p><pre><code class="language-julia-repl">julia&gt; Float64(ft(big(pi) / 2))
2.114425886215604e-49</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This function uses the fixed Talbot method. It evaluates the Laplace transform function for complex arguments. The GWR method is, in general, less accurate and less stable, but does not evaluate the Laplace transform function for complex arguments.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/e9b893aadb9384ad4a07fbe64ef98d68e2ffed05/src/InverseLaplace.jl#L17-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.ILT" href="#InverseLaplace.ILT"><code>InverseLaplace.ILT</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ILT(function, Nterms=32)</code></pre><p>This is an alias for the default <code>Talbot()</code> method.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/e9b893aadb9384ad4a07fbe64ef98d68e2ffed05/src/InverseLaplace.jl#L77-L81">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.GWR" href="#InverseLaplace.GWR"><code>InverseLaplace.GWR</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>ft::GWR = GWR(func::Function, Nterms::Integer=16)</p><p>Return <code>ft</code>, which estimates the inverse Laplace transform of <code>func</code> with the GWR algorithm. <code>ft(t)</code> evaluates the transform at <code>t</code>.</p><p><strong>Example</strong></p><p>Compute the inverse transform of the transform of <code>cos</code> at argument <code>pi / 2</code>.</p><pre><code class="language-none">julia&gt; ft = GWR(s -&gt; s / (s^2 + 1), 16);

julia&gt; ft(pi / 2)
-0.001</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/e9b893aadb9384ad4a07fbe64ef98d68e2ffed05/src/InverseLaplace.jl#L53-L68">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.Weeks" href="#InverseLaplace.Weeks"><code>InverseLaplace.Weeks</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>w::Weeks{datatype} = Weeks(func::Function, Nterms::Integer=64, sigma=1.0, b=1.0; datatype=Float64)</p><p>Return <code>w</code>, which estimates the inverse Laplace transform of <code>func</code> with the Weeks algorithm. <code>w(t)</code> evaluates the transform at <code>t</code>. The accuracy depends on the choice of <code>sigma</code> and <code>b</code>, with the optimal choices depending on <code>t</code>. <code>datatype</code> should agree with the <code>DataType</code> returned by <code>func</code>. For convenience, <code>datatype=Complex</code> is equivalent to <code>datatype=Complex{Float64}</code></p><p>The call to <code>Weeks</code> that creates <code>w</code> is expensive relative to evaluation via <code>w(t)</code>.</p><p><strong>Example</strong></p><p>Compute the inverse transform of the transform of <code>cos</code> at argument <code>pi/2</code>.</p><pre><code class="language-none">julia&gt; ft = Weeks(s -&gt; s/(s^2+1), 80);

julia&gt; ft(pi/2)
0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/e9b893aadb9384ad4a07fbe64ef98d68e2ffed05/src/weeks.jl#L31-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.WeeksErr" href="#InverseLaplace.WeeksErr"><code>InverseLaplace.WeeksErr</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>w::WeeksErr{datatype} = WeeksErr(func::Function, Nterms::Integer=64, sigma=1.0, b=1.0; datatype=Float64)</p><p>Return <code>w</code>, which estimates the inverse Laplace transform of <code>func</code> via the Weeks algorithm. <code>w(t)</code> returns a tuple containing the inverse transform at <code>t</code> and an error estimate. The accuracy of the inversion depends on the choice of <code>sigma</code> and <code>b</code>. See the documentation for <code>Weeks</code> for a description of the parameter <code>datatype</code>.</p><p><strong>Example</strong></p><p>Compute the inverse transform of the transform of <code>cos</code>, and an error estimate, at argument <code>pi/2</code> using <code>80</code> terms.</p><pre><code class="language-none">julia&gt; ft = WeeksErr(s -&gt; s/(s^2+1), 80);

julia&gt; ft(pi/2)
(0.0,3.0872097665938698e-15)</code></pre><p>This estimate is more accurate than <code>cos(pi/2)</code>.</p><pre><code class="language-none">julia&gt; ft(pi/2)[1] - cos(pi/2)
-6.123233995736766e-17

julia&gt; ft(pi/2)[1] - 0.0         # exact value
0.0

julia&gt; ft(pi/2)[1] - cospi(1/2)  # cospi is more accurate
0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/e9b893aadb9384ad4a07fbe64ef98d68e2ffed05/src/weeks.jl#L165-L193">source</a></section><h2><a class="nav-anchor" id="Setting-parameters-1" href="#Setting-parameters-1">Setting parameters</a></h2><p>The inverse Laplace tranform routines should not be treated as black boxes. They are prone to instability and can give inaccurate or wrong results. There are some parameters you can set to try to minimize these problems.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.setNterms" href="#InverseLaplace.setNterms"><code>InverseLaplace.setNterms</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">setNterms(ailt::AbstractILt, Nterms::Integer)</code></pre><p>set the number of terms used in the inverse Laplace tranform <code>ailt</code>. If <code>ailt</code> stores internal data, it will be recomputed, so that subsequent calls <code>ailt(t)</code> reflect the new value of <code>Nterms</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/e9b893aadb9384ad4a07fbe64ef98d68e2ffed05/src/InverseLaplace.jl#L134-L140">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.optimize" href="#InverseLaplace.optimize"><code>InverseLaplace.optimize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">optimize(w::AbstractWeeks, t, Nterms)</code></pre><p>Optimize the parameters of the inverse Laplace transform <code>w</code> at the argument <code>t</code>. If <code>Nterms</code> is ommitted, the current value of <code>w.Nterms</code> is retained.</p><p>The accuracy of the Weeks algorithm depends strongly on <code>t</code>. For some ranges of <code>t</code>, the accuracy is relatively insensitive to the parameters. For other values of <code>t</code>, even using optimized parameters results in estimates of the inverse transform that are extremely inaccurate.</p><p><code>optimize</code> is expensive in CPU time and allocation, it performs nested single-parameter optimization over two parameterss.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/e9b893aadb9384ad4a07fbe64ef98d68e2ffed05/src/weeks.jl#L75-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.opteval" href="#InverseLaplace.opteval"><code>InverseLaplace.opteval</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">opteval(w::AbstractWeeks, t, Nterms)</code></pre><p>estimate an inverse Laplace transform at argument <code>t</code> using <code>w</code> after optimizing the parameters for <code>t</code>. If <code>Nterms</code> is omitted, then the current value of <code>w.Nterms</code> is used.</p><p>Use <code>Weeks</code> or <code>WeeksErr</code> to create <code>w</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/e9b893aadb9384ad4a07fbe64ef98d68e2ffed05/src/weeks.jl#L95-L103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.setparameters" href="#InverseLaplace.setparameters"><code>InverseLaplace.setparameters</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">setparameters(w::AbstractWeeks, sigma, b, Nterms)</code></pre><p>Set the parameters for the inverse Laplace transform object <code>w</code> and recompute the internal data. Subsequent calls <code>w(t)</code> will use these parameters. If <code>Nterms</code> or both <code>Nterms</code> and <code>b</code> are omitted, then their current values are retained.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/e9b893aadb9384ad4a07fbe64ef98d68e2ffed05/src/weeks.jl#L111-L117">source</a></section><h2><a class="nav-anchor" id="Analzying-accuracy-1" href="#Analzying-accuracy-1">Analzying accuracy</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.ILtPair" href="#InverseLaplace.ILtPair"><code>InverseLaplace.ILtPair</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ILtPair(ilt::AbstractILt, ft::Function)</code></pre><p>return an object of type <code>ILtPair</code> that associates <code>ilt</code> the inverse Laplace transform of a function with it &quot;exact&quot; numerical inverse <code>ft</code>. Calling <code>abserr(p, t)</code> returns the absolute error between the inverse transform and the exact value.</p><p><strong>Example</strong></p><p>This example compares the inversion using the Weeks algorithm of the Laplace transform of <code>cos(t)</code> to its exact value at <code>t=1.0</code>.</p><pre><code class="language-none">julia&gt; p = ILtPair(Weeks(s -&gt; s/(1+s^2)), cos);
julia&gt; abserr(p, 1.0)

0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/e9b893aadb9384ad4a07fbe64ef98d68e2ffed05/src/pairtest.jl#L14-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.abserr" href="#InverseLaplace.abserr"><code>InverseLaplace.abserr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">abserr(p::ILtPair, t)</code></pre><p>Compute the absolute error between the estimated inverse Laplace transform and &quot;exact&quot; numerical solution contained in <code>p</code> at the point <code>t</code>. See <code>ILtPair</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/e9b893aadb9384ad4a07fbe64ef98d68e2ffed05/src/pairtest.jl#L57-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.iltpair_power" href="#InverseLaplace.iltpair_power"><code>InverseLaplace.iltpair_power</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">iltpair_power(n)</code></pre><p>Return a <code>TransformPair</code> for the power function <code>x^n</code>. This can be used to construct an <code>ILTPair</code>.</p><pre><code class="language-julia-repl">julia&gt; p  = Talbot(iltpair_power(3));

julia&gt; Float64(abserr(p, 1)) # test Talbot method for Laplace transform of x^3, evaluated at 1
2.0820366247539812e-26</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/e9b893aadb9384ad4a07fbe64ef98d68e2ffed05/src/pairtest.jl#L38-L50">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.TransformPair" href="#InverseLaplace.TransformPair"><code>InverseLaplace.TransformPair</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">TransformPair{T,V}</code></pre><p>A pair of functions for analyzing an inverse Laplace transform method. Field <code>ft</code> is the real-space function. Field <code>fs</code> is the Laplace-space function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/e9b893aadb9384ad4a07fbe64ef98d68e2ffed05/src/pairtest.jl#L3-L8">source</a></section><h2><a class="nav-anchor" id="Lower-level-interface-1" href="#Lower-level-interface-1">Lower-level interface</a></h2><p>Some of the lower-level routines can be called directly, without constructing types defined in <code>InverseLaplace</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.ilt" href="#InverseLaplace.ilt"><code>InverseLaplace.ilt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ilt(func::Function, t::AbstractFloat, M::Integer=32)</code></pre><p><code>ilt</code> is an alias for the default inverse Laplace transform method <code>talbot</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/e9b893aadb9384ad4a07fbe64ef98d68e2ffed05/src/InverseLaplace.jl#L126-L130">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.talbot" href="#InverseLaplace.talbot"><code>InverseLaplace.talbot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">talbot(func::Function, t::AbstractFloat, M::Integer=talbot_default_num_terms)</code></pre><p>Evaluate the inverse Laplace transform of <code>func</code> at the point <code>t</code>. Use <code>M</code> terms in the algorithm. For <code>typeof(t)</code> is <code>Float64</code>, the default for <code>M</code> is <code>32</code>. For <code>BigFloat</code> the default is <code>64</code>.</p><p>If <code>BigFloat</code> precision is larger than default, try increasing <code>M</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; InverseLaplace.talbot(s -&gt; 1 / s^3, 3)
4.50000000000153</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This function uses the fixed Talbot method. It evaluates <code>func</code> for complex arguments.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/e9b893aadb9384ad4a07fbe64ef98d68e2ffed05/src/fixed_talbot.jl#L7-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.gwr" href="#InverseLaplace.gwr"><code>InverseLaplace.gwr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gwr(func::Function, t::AbstractFloat, M::Integer=gwr_default_num_terms)</code></pre><p>Evaluate the inverse Laplace transform of <code>func</code> at the point <code>t</code>. Use <code>M</code> terms in the algorithm. For <code>typeof(t)</code> is <code>Float64</code>, the default for <code>M</code> is <code>16</code>. For <code>BigFloat</code> the default is <code>64</code>.</p><p>If <code>BigFloat</code> precision is larger than default, try increasing <code>M</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; InverseLaplace.gwr( s -&gt; 1/s^3, 3.0)
4.499985907607361</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This function uses the Gaver-Wynn rho method. It evaluates <code>func</code> only for real arguments.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/e9b893aadb9384ad4a07fbe64ef98d68e2ffed05/src/gwr.jl#L12-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InverseLaplace.talbotarr" href="#InverseLaplace.talbotarr"><code>InverseLaplace.talbotarr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">talbotarr(func, ta::AbstractArray, M)</code></pre><p>Compute the inverse Laplace transform for each element in <code>ta</code>. Each evaluation of <code>func(s)</code> is used for all elements of <code>ta</code>. This may be faster than a broadcast application of <code>talbot</code> (i.e. <code>talbot.(...</code>) , but is in general, less accurate.  <code>talbotarr</code> uses the &quot;fixed&quot; Talbot method.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jlapeyre/InverseLaplace.jl/blob/e9b893aadb9384ad4a07fbe64ef98d68e2ffed05/src/fixed_talbot.jl#L50-L57">source</a></section><h2><a class="nav-anchor" id="References-1" href="#References-1">References</a></h2><p>J.A.C Weideman, <em>Algorithms for Parameter Selection in the Weeks Method for Inverting the Laplace Transform, SIAM Journal on Scientific Computing</em>, Vol. 21, pp. 111-128 <strong>(1999)</strong></p><p>Abate, J. and Valkó, P.P., <em>Multi-precision Laplace transform inversion International Journal for Numerical Methods in Engineering</em>, Vol. 60 (Iss. 5-7) pp 979–993 <strong>(2004)</strong></p><p>Valkó, P.P. and Abate, J., <em>Comparison of Sequence Accelerators for the Gaver Method of Numerical Laplace Transform Inversion</em>, Computers and Mathematics with Application,  Vol. 48 (Iss.3-40) pp. 629-636 <strong>(2004)</strong></p><footer><hr/></footer></article></body></html>
